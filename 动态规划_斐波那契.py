# 这段代码就实现了斐波那契数列的动态规划解法。通过建立一个数组F来保存子问题的解，我们避免了重复计算，大大提高了效率。

# 当然，斐波那契数列只是最简单的动态规划问题，实际问题往往会更复杂。但是，只要你理解了动态规划的基本步骤，就可以应对大部分的动态规划问题。


def fib(n):
    F = [0,1] + [0] * (n - 1)
    for i in range(2,n + 1):
        F[i] = F[i - 1] + F[i - 2]
    return F

print(fib(10))


# 动态规划是一种在数学和计算机科学中用来解决优化问题的方法。这种方法的核心思想是将一个复杂的问题分解成一系列简单的子问题，并将子问题的解存储起来，以便在后续的计算中重复使用。

# 动态规划常常用在需要多次决策的问题上，它的主要特点是每一步的决策只依赖于前一步的状态，对前一步以前的决策不做任何假设。它通常是一种以空间换时间的方法。

# 以下是动态规划的基本步骤：

# 问题分解：将问题分解成一些小问题，并找出这些小问题之间的关系。
# 递推公式：根据小问题之间的关系，建立递推公式。
# 边界条件：确定边界条件，也就是最小子问题的解。
# 计算顺序：从小问题到大问题的计算顺序。
# 记忆化：将子问题的解存储起来，避免重复计算。
# 接下来，让我们通过一个经典的问题——斐波那契数列——来理解动态规划的过程。

# 斐波那契数列定义如下：

# F(0) = 0
# F(1) = 1
# F(n) = F(n-1) + F(n-2), 对于n > 1
# 我们可以看到，斐波那契数列的问题可以分解成子问题，即求F(n-1)和F(n-2)。这就是第一步。

# 接着，我们可以找到递推公式，就是上面的F(n) = F(n-1) + F(n-2)。

# 然后，边界条件就是F(0) = 0，F(1) = 1。

# 计算顺序是从小到大，即从F(0)、F(1)开始，逐渐计算到F(n)。

# 最后，记忆化的步骤可以通过一个数组来实现，我们可以创建一个数组F，并将F(i)的结果保存在F[i]中。